#! bin/bash
### BEGIN INIT INFO
# Provides:          myservice
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start daemon at boot time
# Description:       Enable service provided by daemon.
### END INIT INFO

# 以上注释用于服务管理程序(chkconfig/update-rc.d)读取该服务的启动级别等必要信息

# 脚本必须增加可执行权限 root# chmod u+x /etc/init.d/myservice

# 在定义命令之前通常要做一些必要的检测工作,比如检测服务依赖的基础环境是否具备,设置一些变量方便脚本使用

#####################################################################################
# 配置服务自启动
# chkconfig myservice on

# 检查服务的启动级别,如果2,3,4,5为启用,表示服务自启动成功(在命令行和桌面环境下都会自启动)
# chkconfig --list myservice

# 关闭服务自启动
# chkconfig myservice off
######################################################################################

start()
{
    echo "正在启动某某服务...\n"
    # 这下面写上具体的可执行文件的路径和执行时的参数,例如要启动apache
    # /opt/apache_2_2_23/bin/httpd -k start &
    
    # 如果更完善,通常要检查aaa.php文件是否存在,aaa.php是否正常运行等必要内容,
    # 也许还需要检测是否已经开启了服务(如果不允许重复开启)
    
    # aaa.php也需要有可执行权限,并在文件首行定义为脚本文件  #! path/to/php
    
    ~/aaa.php & 
    echo "服务启动完成"
    exit 0;
}
stop()
{
    
    echo -n "正在停止某某服务...\n"
    # 结束服务 
    # 方式1:因为大多linux程序都自带了结束自身的命令参数,使用程序自带的退出参数结束,以在结束任务之前,执行必要的数据处理工作
    # /opt/apache_2_2_23/bin/httpd -k stop
    
    # 方式2:使用pkill命令根据脚本的文件名结束任务,注意如果有多个进程是同一个文件开启,会全部结束!
    # 方式3:获取进程的pid,使用kill命令结束任务
    if pkill aaa.php
        then
        echo  "[某某服务已停止]"

    else
        echo  "[某某服务停止失败]"
    fi
}

case "$1" in
start)
    #当入参为start时,执行的函数
    start
    ;;
stop)
    stop
    ;;
restart)
    stop
    start
    ;;
*)
    # 如果参数不合法,提示用户允许使用的参数
    echo "usage: $0 start|stop|restart"
    exit 0;
esac
